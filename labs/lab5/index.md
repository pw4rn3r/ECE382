title = 'Lab 5 - Interrupts - "Remote Control Decoding"'

# Lab 5 - Interrupts - "Remote Control Decoding"

## Objectives

In this lab, you'll use your knowledge of interrupts and the Timer_A subsytem to reverse engineer a remote control.  

## Handy References
- Information on the [Sony SIRC Protocol](http://users.telenet.be/davshomepage/home.htm)
- You can verify your remote's button codes [here](http://lirc.sourceforge.net/remotes/)

## Given code
- [test5.c](test5.c) - Use this file to characterize the buttons of your remote
- [start5.c](start5.c) - Initial template file for lab
- [start5.h](start5.h) - Initial template file for lab

## Prelab

Read the assignment so you can make good use of your time in class.  You can also get a head start filling in the blank sections of code on test5.c.

## Details

### The Basic Idea

You will need to use the timer interrupt and the general purpose pin interrupt to decode a remote control.  Be sure to pick one remote for the whole lab, as remote codes vary.  

**Lab day 1:** Learn the timing and bit patterns for your IR remote control (i.e., reverse-engineer its protocol)
 
**Lab day 2:** Demonstrate your code can receive and decode button presses from the remote control by using your remote to toggle LEDs

**Lab day 3:** Control etch-a-sketch or pong using your remote

## Group Work Requirements
####If you are considering working on Lab 5 as a group here are the requirements:
- **Max Group size is 2**
- You must create a separate shared repo for the group to the shared repo named ECE382_LastName1_LastName2
- Each team member will place a link at the top of a readme in your personal repo in a Lab 5 folder
- Both partners must make contributions to the Lab and document contributions in commit messages
- Most likely you will have to switch your CCS workspace to a new folder to separate your repo from your private repo
- Don't forget to give you instructor access to the repo
- The expectation is that if you have twice the team members that you will have a better product
- Remember you **commit** to you own local copy of the repo, you **push** your to the cloud, and you **pull** the cloud copy to your local copy
- You may want to review merging and branching allow for better collaboration [merge a file](https://confluence.atlassian.com/bitbucket/use-a-git-branch-to-merge-a-file-681902555.html) or [git merge](https://git-scm.com/docs/git-merge)

## Lab day 1 (40 pts)

The results of these activities should be posted to Bitbucket.


### 1) Complete the test code for characterizing your remote

You will need to fill in the six blank lines of code in [test5.c](test5.c) in the initMSP() suboutine.  This code will prepare the TimerA0 subsystem for use.


### 2) Connect the IR sensor to your MSP430 Launchpad and a Logic Analyzer
Insert the IR receiver module into a small protoboard.  Use M/F wires to connect your protoboard to your MSP430. Use a regular hard wire to connect your signal and ground to the logic analyzer.

Per the figure below, when you are looking at the sensor ball on your IR receiver module, the pin on the left is your signal pin; the pin in the middle is your ground pin; and the pin on the right is your Vcc.

<br>
![IR Sensor Datasheet exerpt](ir_sensor.jpg)
<br>

Set up your LaunchPad like the picture below. Make sure to connect the power and ground in the correct order! On your MSP430, connect the signal pin to XIN/P2.6 on J2, the ground pin to the GND pin on J6, and the Vcc pin to Vcc on J6.

![LaunchPad setup](launchpadSetup.jpg)
<br>

Connect the the logic analyzer on the Vout pin of the IR receiver.  


### 3) Capture an IR waveform on the Logic Analyzer

Use the logic analyzer to examine and characterize the IR waveforms generated by a remote control of your choice.

**(1 pt) Question 1:**  What is the make and model of your remote?

Configure the logic analyzer to collect data on an edge change, with at least 90% of the data stored post-trigger.  On my remote control, the full remote control signal was about 65ms. Please note that remote control data packets are not standardized by any means, so the remote that you use to perform these experiment will almost certainly generate results different  from those that your neighbor's remote will generate.


**(4 pts) Waveform screenshot with labels:**
Provide a screenshot of a waveform that you captured following a single button press.  Be sure to identify what button was pressed and provide labels for start, data 0, data 1, and stop bits.


**(1 pt) Question 2:**  What is the total length of your signal from the start bit to the stop bit?


**(8 pts) Complete Table 1**
List the lengths of the pulses generated by the remote control in absolute time using the logic analyzer (3 significant figures).  Then, based on the timer settings in [test5.c](test5.c), calculate and provide timer A counts.  Note: "start -- logic 0 half pulse" refers to the logic LOW portion of the start pulse, and "data 0 -- logic 1 half pulse" refers to the second half (which is a logic HIGH) of the pulse representing a zero bit.

| Pulse | Duration (ms)	| Timer A counts |
| :-: | :-: | :-: |
| Start -- logic 0 half pulse | | |
| Start -- logic 1 half pulse | | | 	 
| Data 1 -- logic 0 half pulse | | | 	 
| Data 1 -- logic 1 half pulse | | |	 
| Data 0 -- logic 0 half pulse | | |	 
| Data 0 -- logic 1 half pulse | | |	 
| Stop -- logic 0 half pulse | | | 
| Stop -- logic 1 half pulse | | | |

##### Table 1.  Pulse durations for captured IR signal


### 4) Use a timer to capture waveform timings

Build a project around your modified [test5.c](test5.c) and then download it onto your LaunchPad. Make sure to open the variables tab (View -> Variables). I also like to clear memory from the Memory Browser tab (View -> Memory Browser), Fill Memory from 0x200 to 0x400 with 0's. Run the program, set the logic analyzer to capture, and then press the same button on the remote that you used in the last logic analyzer capture. Then pause the program and look at the variables. You should see something like the following.
 <br>
![array screen shot](arrayScreenShot.gif)
<br>

Note, the differences in counts should closely match the differences in timing shown in the waveform on the logic analyzer.

A few questions about what goes on in this program are in order before we proceed.

**(1 pt) Question 3:** How long will it take the timer to roll over?

**(1 pt) Question 4:** How long does each timer count last?


The while(1) loop in main reads in the IR pulse in the for loop. 

**(6 pts) Question 5:** Annotate the picture below to indicate which line of the for loop in the program is executed at which part of the pulse. You should show a total of 6 lines of code (lines 32-34 and lines 36-38).
<br>
![IR wave](irWave.gif)
<br>



### 5) Use captured data to characterize in timer counts what a start, stop, data 0, and data 1 bit is

Collect and tabulate in MS Excel **eight** samples of timer A counts (in decimal) for each of the following three pulse types listed in Table 2 below. Note, your logic 0 half-pule width is most likely to be the same regardless if the data bit is a 1 or 0.  Compute the average and standard deviation of each pulse type. I would suggest just grabbing it from the CCS variables tab. 

For each pulse type list the range (lower and upper) of timer A counts that would correctly classify 99.9999426697% of the pulses for a normal distribution of data (within five standard deviations).
<br> 

**Summarize your results in Table 2 (6 pts):**


| **Data half-pulse** | **Average** | **Std Dev** | **Lower timer count** | **Upper timer count** |
|---------------------|-------------|-------------|-----------------------|-----------------------|
| Data 1 logic 1      |             |             |                       |                       |
| Data 0 logic 0      |             |             |                       |                       |
| Data 0 logic 1      |             |             |                       |                       |

##### Table 2.  Data half-pulse charaterization


<br>



### 6) Find 10 button codes (10 pts)

Using the derived criteria for classifying bits in Table 2, experimentally find the hexadecimal codes for 10 remote control buttons.  Provide your results in Table 3 below.  Note, "Button name" refers to CH+, 6, VOL-, Power, etc.

| Button | Button name | Hex code (not including start and stop bits) |
| :-: | :-: | :-: |
| 1 | | |	 
| 2 | | | 
| 3 | | |	 
| 4 | | | 
| 5 | | |	 
| 6 | | | 
| 7 | | | 
| 8 | | |
| 9 | | |
| 10 | | | |

##### Table 3.  Hexadecimal button codes


<br>

**(1 pts) Question 6:** Does your button transmit a different code or provide any indication that a button is being held?  If so, provide a screenshot with labels and/or explanation.

**(1 pts) Question 7:** Given your answer to the previous question, how will you handle held button inputs in your code logic?



## Day 2 Required Functionality - Control LEDs remotely (30 pts)

Now that you know how to detect certain button presses based on timing values, you need to create code to capture the timing values for decoding button presses.  You may use [start5.c](start5.c) and [start5.h](start5.h) as a starting point.  Demonstrate to your instructor that your code can receive and decode button presses from the remote control by toggling LEDs with your remote.

Turn an LED on and off with one button on the remote.  Turn another LED on and off with a different button.  Turn both LEDs on and off with a third button.  You decide what happens if you hold any buttons.

In addition to the start.c and start.h files, the below image may be of some use: 
<br>
![schematic](schematic.jpg)
<br>


## Day 3 - Control your Lab 4 game (20 pts)

#### Configure hardware
Connect a LCD boosterpack to your MSP430 launchpad.  The pin used for the IR input is shared with a boosterpack LED, which is connected to a pull-up resistor!  Disconnect the pull-up resistor by removing the L2 jumper.

#### Write software to implement functionality
Use the buttons on a remote control to either control your Lab #4 etch-a-sketch (up, down, right, left, color) or your pong game.


## Code (10 pts)

Your code must be pushed to your Bitbucket account.  Make sure you are using good coding practices providing documentation within you code.


## Hints

- Code that works when you quickly press a button may break if you hold the button

- How long does your timer rollover value need to be?  What is the longest you will ever wait once you start reading a code?

- Watch out for IR interference!
 - Look at the logic analyzer output while you run your code.
 - The first bytes (manufacturer's code) should generally be the same for your buttons.  
 - If the waveform does not look correct in the logic analyzer, rerun that button test!

**Before recording values from a test**
- Make sure your RAM is cleared
- Note the corresponding waveform in the logic analyzer (your code may not capture the timing correctly)
 
**Note the *pattern* of bits in the waveform**
- You are reverse engineering a protocol
- Your code only sees the information that your timer provides (it is not as accurate as the logic analyzer)
- If possible, compare your results to known values such as those provided by the [LIRC project](http://lirc.sourceforge.net/remotes/).

**When using the LCD, do not forget to disconnect the boosterpack LED jumper!**

**I say again, do not forget to disconnect the boosterpack LED jumper!**  If you are using the logic analyzer, it will be obvious that your hardware setup is incorrect.



## Grading - Lab 5
[Printable Lab 5 Cutsheet](Lab_5_Cutsheet.pdf)

**Name:**<br>
<br>
**Section:**
<br>
<br>
**Documentation:**<br>
<br>


| **Item**                   | **Grade**                                                                                                                         | **Points** | **Out of** | **Date** | **Due** |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------|------------|------------|----------|---------|
| **Day 1 activities**       | **On-Time** -------------------------------------------------------------------- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days |            | 40         |          | BOC L29 |
| **Required Functionality** | **On-Time** -------------------------------------------------------------------- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days |            | 30         |          | COB L30 |
| **Game Functionality**     | **On-Time** -------------------------------------------------------------------- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days |            | 20         |          | COB L30 |
| **Code**                   | **On-Time:** Zero ---- Check Minus ---- Check ---- Check Plus ---- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days               |            | 10         |          | COB L30 |
| **Total**                  |                                                                                                                                   |            | **100**    |          |         |
